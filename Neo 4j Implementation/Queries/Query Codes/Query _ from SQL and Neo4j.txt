SQL Queries


Query to Calculate Total Amount


WITH OrderProducts AS (
    SELECT
        sl.Order_Number,
        sl.ProductKey,
        ROUND((er.Unit_Price_USD * sl.Quantity), 2) AS Total_Amount_product,
        sl.StoreKey,
        sl.Order_Date,
        sl.CustomerKey,
        sl.Quantity,
        -- Assign row number per order, ordered by ProductKey
        ROW_NUMBER() OVER (
            PARTITION BY sl.Order_Number 
            ORDER BY sl.ProductKey
        ) AS rn
    FROM Products er 
    INNER JOIN sales sl ON er.ProductKey = sl.ProductKey
)
SELECT
    Order_Number,
   cast( ProductKey as int)AS  First_ProductKey,
    Total_Amount_product,
    StoreKey,
    Order_Date,
    CustomerKey,
    Quantity
FROM OrderProducts
WHERE rn = 1;


------------------------------------------------------------------------------------------------------------




1) select sf.Order_Number,sf.CustomerKey,sf.Total_Amount,sto.Country 
from Sales_Fact sf right join
Stores_Dim sto on sf.StoreKey = sf.StoreKey

2) select ROUND( Max(Total_Amount),2) maximum_total_Amount,ROUND( MIN(Total_Amount),2) minimum_total_Amount,ROUND( AVG(Total_Amount),2 )average_total_Amount
from Sales_Fact 


3) select  *  from Products_Dim where Category in (5,2)


4) select sf.Order_Number,pd.ProductKey , pd.Product_Name,pd.Category,sf.Total_Amount  from Sales_Fact sf 
inner join Products_Dim pd on sf.ProductKey = pd.ProductKey where sf.Total_Amount > 500 
and pd.Category in (5,2) 


5) select Top 5  Product_Name,Order_Number , Total_Amount from  Sales_Fact sf
right join Products_Dim pd on pd.ProductKey = sf.ProductKey order by Total_Amount desc

6) select Top 5  cd.Name,Order_Number , Total_Amount from  Sales_Fact sf
right join Customers_Dim cd on cd.CustomerKey = sf.CustomerKey order by Total_Amount desc


7) select *  from Sales_Fact where Quantity >=5



_______________________________________________________________________



Neo4J Queries

Query 1: Get orders with store country

MATCH (sto:Store)
OPTIONAL MATCH (c:Customer)-[:PLACED]->(o:Order)-[:ORDERED_FROM]->(sto)
RETURN o.order_id AS Order_Number,
       c.customer_id AS CustomerKey,
       o.amount AS Total_Amount,
       sto.country AS Country;

Query 2: Aggregated order amounts

MATCH (o:Order)
RETURN 
  ROUND(MAX(o.amount), 2) AS MaxAmount,
  ROUND(MIN(o.amount), 2) AS MinAmount,
  ROUND(AVG(o.amount), 2) AS AvgAmount;


Query 3: Products with category 5 or 2

MATCH (p:Product)
WHERE p.category IN ['5', '2']
RETURN p.product_id, p.name, p.category;

Query 4: High value orders for category 5 or 2 products

MATCH (o:Order)-[:CONTAINS_PRODUCT]->(p:Product)
WHERE o.amount > 500 AND p.category IN ['5','2']
RETURN o.order_id, p.product_id, p.name, p.category, o.amount;

Query 5: Top 5 most expensive orders (with product info)

MATCH (o:Order)-[:CONTAINS_PRODUCT]->(p:Product)
RETURN p.name, o.order_id, o.amount
ORDER BY o.amount DESC
LIMIT 5;


Query 6: Top 5 customers by order amount

MATCH (c:Customer)-[:PLACED]->(o:Order)
RETURN c.name, o.order_id, o.amount
ORDER BY o.amount DESC
LIMIT 5;




Query 7: Orders with quantity >= 5

MATCH (o:Order)
WHERE o.quantity >= 5
RETURN o.order_id, o.amount, o.quantity;


--------------------------------------------------------------------


Nodes & Relationships

Customer Node

LOAD CSV WITH HEADERS FROM 'file:///customers.csv' AS row
CREATE (:Customer {
  customer_id: toInteger(row.CustomerKey),
  name: row.Name,
  gender: row.Gender,
  country: row.Country,
  state: row.State,
  city: row.City,
  continent: row.Continent
});

Product Node

LOAD CSV WITH HEADERS FROM 'file:///products.csv' AS row
CREATE (:Product {
  product_id: toInteger(row.ProductKey),
  name: row.Product_Name,
  brand: row.Brand,
  category: row.Category,
  price: toFloat(row.Unit_Price_USD)
});

Store Node

LOAD CSV WITH HEADERS FROM 'file:///stores.csv' AS row
CREATE (:Store {
  store_id: toInteger(row.StoreKey),
  country: row.Country,
  state: row.State,
  square_meters: toInteger(row.Square_Meters),
  open_date: row.Open_Date
});

Date Node

LOAD CSV WITH HEADERS FROM 'file:///dates.csv' AS row
CREATE (:Date {
  date_id: toInteger(row.date_key),
  full_date: row.FullDate,
  month: row.Month,
  quarter: row.Quarter_,
  year: row.Year
});


Order Node and Relationships

1)

LOAD CSV WITH HEADERS FROM 'file:///orders.csv' AS row
MERGE (c:Customer {customer_id: toInteger(row.CustomerKey)})
MERGE (p:Product {product_id: toInteger(row.ProductKey)})
MERGE (s:Store {store_id: toInteger(row.StoreKey)})
MERGE (d:Date {date_id: toInteger(row.DateKey)})
CREATE (o:Order {
  order_id: row.Order_Number,
  amount: toFloat(row.Total_Amount),
  quantity: toInteger(row.Quantity)
})
MERGE (c)-[:PLACED]->(o)
MERGE (o)-[:CONTAINS_PRODUCT]->(p)
MERGE (o)-[:ORDERED_FROM]->(s)
MERGE (o)-[:ON_DATE]->(d);


2)

LOAD CSV WITH HEADERS FROM 'file:///products.csv' AS row
MERGE (cat:category {category: row.Category})
WITH cat,row
MATCH (p:product {product_id: toInteger(row.ProductKey)})
MERGE (p)-[:BELONGS_TO]->(cat)


3)

LOAD CSV WITH HEADERS FROM 'file:///customers.csv' AS row
MERGE (city:City {name: row.City})
WITH city,row
MATCH (c:Customer {customer_id: toInteger(row.CustomerKey)})
MERGE (c)-[:LIVES_IN]->(city)


4)

LOAD CSV WITH HEADERS FROM 'file:///customers.csv' AS row
MERGE (country:Country {name: row.Country})
WITH country,row
MATCH (s:Store {store_id: toInteger(row.StoreKey)})
MERGE (s)-[:LOCATED_IN]->(country)

